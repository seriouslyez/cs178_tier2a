'use strict';

/** @ignore */
function _some(obj, pred) {
    const keys = Object.keys(obj);
    return keys.some((key) => pred(obj[key]));
}

/** @ignore */
function _mapValues(obj, updater) {
    const keys = Object.keys(obj || {});
    return keys.reduce((acc, key) => (Object.assign(Object.assign({}, acc), { [key]: updater(obj[key]) })), {});
}

/** @category Helper */
function isFieldValue(value) {
    if (Array.isArray(value)) {
        if (value.length === 0)
            return true;
        return value.some((v) => v instanceof File || typeof v === 'string');
    }
    return (typeof value === 'string' ||
        typeof value === 'number' ||
        typeof value === 'boolean' ||
        value instanceof File);
}

/** @ignore */
function _isPlainObject(value) {
    return Object.prototype.toString.call(value) === '[object Object]';
}

/** @ignore */
function _cloneDeep(obj) {
    return Object.keys(obj || {}).reduce((res, key) => (Object.assign(Object.assign({}, res), { [key]: _isPlainObject(obj[key])
            ? _cloneDeep(obj[key])
            : Array.isArray(obj[key])
                ? [...obj[key]]
                : obj[key] })), {});
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function handleArray(value) {
    return function (propVal) {
        if (_isPlainObject(propVal)) {
            const _a = deepSet(propVal, value), field = __rest(_a, ["key"]);
            return field;
        }
        return value;
    };
}
/**
 * @category Helper
 */
function deepSet(obj, value) {
    return _mapValues(obj, (prop) => _isPlainObject(prop)
        ? deepSet(prop, value)
        : Array.isArray(prop)
            ? prop.map(handleArray(value))
            : value);
}

/** @ignore */
function _mergeWith(...args) {
    const customizer = args.pop();
    const _obj = args.shift();
    if (typeof _obj === "string")
        return _obj;
    const obj = _cloneDeep(_obj);
    if (args.length === 0)
        return obj;
    for (const source of args) {
        if (!source)
            continue;
        if (typeof source === "string")
            return source;
        let rsValue = customizer(obj, source);
        if (typeof rsValue !== 'undefined')
            return rsValue;
        const keys = Array.from(new Set(Object.keys(obj).concat(Object.keys(source))));
        for (const key of keys) {
            rsValue = customizer(obj[key], source[key]);
            if (typeof rsValue !== 'undefined') {
                obj[key] = rsValue;
            }
            else if (_isPlainObject(source[key]) && _isPlainObject(obj[key])) {
                obj[key] = _mergeWith(obj[key], source[key], customizer);
            }
            else if (Array.isArray(source[key])) {
                obj[key] = source[key].map((val, i) => {
                    if (!_isPlainObject(val))
                        return val;
                    const newObj = Array.isArray(obj[key]) ? obj[key][i] : obj[key];
                    return _mergeWith(newObj, val, customizer);
                });
            }
            else if (_isPlainObject(source[key])) {
                const defaultObj = deepSet(_cloneDeep(source[key]), undefined);
                obj[key] = _mergeWith(defaultObj, source[key], customizer);
            }
            else if (typeof source[key] !== 'undefined') {
                obj[key] = source[key];
            }
        }
    }
    return obj;
}

function defaultsCustomizer(objValue, srcValue) {
    if (_isPlainObject(objValue) && _isPlainObject(srcValue))
        return;
    if (Array.isArray(srcValue)) {
        if (srcValue.some(_isPlainObject))
            return;
        const objArray = Array.isArray(objValue) ? objValue : [];
        return srcValue.map((value, index) => { var _a; return (_a = objArray[index]) !== null && _a !== void 0 ? _a : value; });
    }
    if (typeof objValue !== 'undefined')
        return objValue;
}
/** @ignore */
function _defaultsDeep(...args) {
    return _mergeWith(...args, defaultsCustomizer);
}

/** @ignore */
function _merge(...args) {
    return _mergeWith(...args, () => undefined);
}

/* From: https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_get */
/** @ignore */
function _get(obj, path, defaultValue) {
    const travel = (regexp) => String.prototype.split
        .call(path, regexp)
        .filter(Boolean)
        .reduce((res, key) => (res !== null && res !== undefined ? res[key] : res), obj);
    const result = travel(/[,[\]]+?/) || travel(/[,[\].]+?/);
    return result === undefined || result === obj ? defaultValue : result;
}

/** @ignore */
function _update(obj, path, updater) {
    if (obj)
        obj = _cloneDeep(obj);
    if (!_isPlainObject(obj))
        obj = {};
    const splitPath = !Array.isArray(path) ? path.match(/[^.[\]]+/g) || [] : path;
    const lastSection = splitPath[splitPath.length - 1];
    if (!lastSection)
        return obj;
    let property = obj;
    for (let i = 0; i < splitPath.length - 1; i++) {
        const section = splitPath[i];
        if (!property[section] ||
            (!_isPlainObject(property[section]) && !Array.isArray(property[section]))) {
            const nextSection = splitPath[i + 1];
            if (isNaN(Number(nextSection))) {
                property[section] = {};
            }
            else {
                property[section] = [];
            }
        }
        property = property[section];
    }
    property[lastSection] = updater(property[lastSection]);
    return obj;
}

/** @ignore */
function _set(obj, path, value) {
    return _update(obj, path, () => value);
}

function _unset(obj, path) {
    if (!obj || Object(obj) !== obj)
        return;
    // When obj is not an object
    else if (typeof obj !== 'undefined')
        obj = _cloneDeep(obj);
    // If not yet an array, get the keys from the string-path
    const newPath = !Array.isArray(path)
        ? path.toString().match(/[^.[\]]+/g) || []
        : path;
    const foundProp = newPath.length === 1 ? obj : _get(obj, newPath.slice(0, -1).join('.'));
    if (Array.isArray(foundProp)) {
        foundProp.splice(Number(newPath[newPath.length - 1]), 1);
    }
    else {
        foundProp === null || foundProp === void 0 ? true : delete foundProp[newPath[newPath.length - 1]];
    }
    return obj;
}

/**
 * @category Helper
 */
function deepSome(obj, pred) {
    return _some(obj, (value) => _isPlainObject(value)
        ? deepSome(value, pred)
        : Array.isArray(value)
            ? value.length === 0 || value.every((v) => typeof v === 'string')
                ? pred(value)
                : value.some((v) => _isPlainObject(v) ? deepSome(v, pred) : pred(v))
            : pred(value));
}

/**
 * @category Helper
 */
function isInputElement(el) {
    return (el === null || el === void 0 ? void 0 : el.nodeName) === 'INPUT';
}
/**
 * @category Helper
 */
function isTextAreaElement(el) {
    return (el === null || el === void 0 ? void 0 : el.nodeName) === 'TEXTAREA';
}
/**
 * @category Helper
 */
function isSelectElement(el) {
    return (el === null || el === void 0 ? void 0 : el.nodeName) === 'SELECT';
}
/**
 * @category Helper
 */
function isFieldSetElement(el) {
    return (el === null || el === void 0 ? void 0 : el.nodeName) === 'FIELDSET';
}
/**
 * @category Helper
 */
function isFormControl(el) {
    return isInputElement(el) || isTextAreaElement(el) || isSelectElement(el);
}
/**
 * @category Helper
 */
function isElement(el) {
    return el.nodeType === Node.ELEMENT_NODE;
}

/**
 * @category Helper
 */
function getPath(el, name) {
    return name !== null && name !== void 0 ? name : (isFormControl(el) ? el.name : '');
}

/**
 * @category Helper
 */
function shouldIgnore(el) {
    let parent = el;
    while (parent && parent.nodeName !== 'FORM') {
        if (parent.hasAttribute('data-felte-ignore'))
            return true;
        parent = parent.parentElement;
    }
    return false;
}

function getValue(storeValue, selectorOrPath) {
    if (!_isPlainObject(storeValue) || !selectorOrPath)
        return storeValue;
    if (typeof selectorOrPath === 'string') {
        return _get(storeValue, selectorOrPath);
    }
    return selectorOrPath(storeValue);
}

function executeCustomizer(objValue, srcValue) {
    if (_isPlainObject(objValue) || _isPlainObject(srcValue))
        return;
    if (objValue === null || objValue === '')
        return srcValue;
    if (srcValue === null || srcValue === '')
        return objValue;
    if (!srcValue)
        return objValue;
    if (!objValue || !srcValue)
        return;
    if (Array.isArray(objValue)) {
        if (!Array.isArray(srcValue))
            return [...objValue, srcValue];
        const newErrors = [];
        const errLength = Math.max(srcValue.length, objValue.length);
        for (let i = 0; i < errLength; i++) {
            let obj = objValue[i];
            let src = srcValue[i];
            if (!_isPlainObject(obj) && !_isPlainObject(src)) {
                if (!Array.isArray(obj))
                    obj = [obj];
                if (!Array.isArray(src))
                    src = [src];
                newErrors.push(...obj, ...src);
            }
            else {
                newErrors.push(mergeErrors([obj !== null && obj !== void 0 ? obj : {}, src !== null && src !== void 0 ? src : {}]));
            }
        }
        return newErrors.filter(Boolean);
    }
    if (!Array.isArray(srcValue))
        srcValue = [srcValue];
    return [objValue, ...srcValue]
        .reduce((acc, value) => acc.concat(value), [])
        .filter(Boolean);
}
function mergeErrors(errors) {
    const merged = _mergeWith(...errors, executeCustomizer);
    return merged;
}
function runValidations(values, validationOrValidations) {
    if (!validationOrValidations)
        return [];
    const validations = Array.isArray(validationOrValidations)
        ? validationOrValidations
        : [validationOrValidations];
    return validations.map((v) => v(values));
}

function executeTransforms(values, transforms) {
    if (!transforms)
        return values;
    if (!Array.isArray(transforms))
        return transforms(values);
    return transforms.reduce((res, t) => t(res), values);
}

function createId(length = 8) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let str = '';
    for (let i = 0; i < length; i++) {
        str += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return str;
}

function isEqual(val1, val2) {
    if (val1 === val2)
        return true;
    if (Array.isArray(val1) && Array.isArray(val2)) {
        if (val1.length !== val2.length)
            return false;
        return val1.every((v, i) => isEqual(v, val2[i]));
    }
    if (_isPlainObject(val1) && _isPlainObject(val2)) {
        const keys1 = Object.keys(val1);
        const keys2 = Object.keys(val2);
        if (keys1.length !== keys2.length)
            return false;
        return keys1.every((k) => isEqual(val1[k], val2[k]));
    }
    return false;
}

function debounce(func, timeout, { onInit, onEnd } = {}) {
    let timer;
    return (...args) => {
        if (!timer)
            onInit === null || onInit === void 0 ? void 0 : onInit();
        if (timer)
            clearTimeout(timer);
        timer = setTimeout(() => {
            func.apply(this, args);
            timer = undefined;
            onEnd === null || onEnd === void 0 ? void 0 : onEnd();
        }, timeout);
    };
}

/**
 * @ignore
 */
function getFormControls(el) {
    if (isFormControl(el))
        return [el];
    if (el.childElementCount === 0)
        return [];
    const foundControls = new Set();
    for (const child of el.children) {
        if (isFormControl(child))
            foundControls.add(child);
        if (isFieldSetElement(child)) {
            for (const fieldsetChild of child.elements) {
                if (isFormControl(fieldsetChild))
                    foundControls.add(fieldsetChild);
            }
        }
        if (child.childElementCount > 0)
            getFormControls(child).forEach((value) => foundControls.add(value));
    }
    return Array.from(foundControls);
}
/**
 * @ignore
 */
function addAttrsFromFieldset(fieldSet) {
    for (const element of fieldSet.elements) {
        if (!isFormControl(element) && !isFieldSetElement(element))
            continue;
        if (fieldSet.hasAttribute('data-felte-keep-on-remove') &&
            !element.hasAttribute('data-felte-keep-on-remove')) {
            element.dataset.felteKeepOnRemove = fieldSet.dataset.felteKeepOnRemove;
        }
    }
}
/** @ignore */
function getInputTextOrNumber(el) {
    if (el.type.match(/^(number|range)$/)) {
        return !el.value ? undefined : +el.value;
    }
    else {
        return el.value;
    }
}
/**
 * @ignore
 */
function getFormDefaultValues(node) {
    var _a;
    let defaultData = {};
    let defaultTouched = {};
    for (const el of node.elements) {
        if (isFieldSetElement(el))
            addAttrsFromFieldset(el);
        if (!isFormControl(el) || !el.name)
            continue;
        const elName = getPath(el);
        if (isInputElement(el)) {
            if (el.type === 'checkbox') {
                if (typeof _get(defaultData, elName) === 'undefined') {
                    const checkboxes = Array.from(node.querySelectorAll(`[name="${el.name}"]`)).filter((checkbox) => {
                        if (!isFormControl(checkbox))
                            return false;
                        return elName === getPath(checkbox);
                    });
                    if (checkboxes.length === 1) {
                        defaultData = _set(defaultData, elName, el.checked);
                        defaultTouched = _set(defaultTouched, elName, false);
                        continue;
                    }
                    defaultData = _set(defaultData, elName, el.checked ? [el.value] : []);
                    defaultTouched = _set(defaultTouched, elName, false);
                    continue;
                }
                if (Array.isArray(_get(defaultData, elName)) && el.checked) {
                    defaultData = _update(defaultData, elName, (value) => [
                        ...value,
                        el.value,
                    ]);
                }
                continue;
            }
            if (el.type === 'radio') {
                if (_get(defaultData, elName))
                    continue;
                defaultData = _set(defaultData, elName, el.checked ? el.value : undefined);
                defaultTouched = _set(defaultTouched, elName, false);
                continue;
            }
            if (el.type === 'file') {
                defaultData = _set(defaultData, elName, el.multiple ? Array.from(el.files || []) : (_a = el.files) === null || _a === void 0 ? void 0 : _a[0]);
                defaultTouched = _set(defaultTouched, elName, false);
                continue;
            }
        }
        else if (isSelectElement(el)) {
            const multiple = el.multiple;
            if (!multiple) {
                defaultData = _set(defaultData, elName, el.value);
            }
            else {
                const selectedOptions = Array.from(el.options)
                    .filter((opt) => opt.selected)
                    .map((opt) => opt.value);
                defaultData = _set(defaultData, elName, selectedOptions);
            }
            defaultTouched = _set(defaultTouched, elName, false);
            continue;
        }
        const inputValue = getInputTextOrNumber(el);
        defaultData = _set(defaultData, elName, inputValue);
        defaultTouched = _set(defaultTouched, elName, false);
    }
    return { defaultData, defaultTouched };
}
function setControlValue(el, value) {
    var _a;
    if (!isFormControl(el))
        return;
    const fieldValue = value;
    if (isInputElement(el)) {
        if (el.type === 'checkbox') {
            const checkboxesDefaultData = fieldValue;
            if (typeof checkboxesDefaultData === 'undefined' ||
                typeof checkboxesDefaultData === 'boolean') {
                el.checked = !!checkboxesDefaultData;
                return;
            }
            if (Array.isArray(checkboxesDefaultData)) {
                if (checkboxesDefaultData.includes(el.value)) {
                    el.checked = true;
                }
                else {
                    el.checked = false;
                }
            }
            return;
        }
        if (el.type === 'radio') {
            const radioValue = fieldValue;
            if (el.value === radioValue)
                el.checked = true;
            else
                el.checked = false;
            return;
        }
        if (el.type === 'file') {
            el.files = null;
            el.value = '';
            return;
        }
    }
    else if (isSelectElement(el)) {
        const multiple = el.multiple;
        if (!multiple) {
            el.value = String(fieldValue !== null && fieldValue !== void 0 ? fieldValue : '');
            for (const option of el.options) {
                if (option.value === String(fieldValue)) {
                    option.selected = true;
                }
                else {
                    option.selected = false;
                }
            }
        }
        else if (Array.isArray(fieldValue)) {
            el.value = String((_a = fieldValue[0]) !== null && _a !== void 0 ? _a : '');
            const stringValues = fieldValue.map((v) => String(v));
            for (const option of el.options) {
                if (stringValues.includes(option.value)) {
                    option.selected = true;
                }
                else {
                    option.selected = false;
                }
            }
        }
        return;
    }
    el.value = String(fieldValue !== null && fieldValue !== void 0 ? fieldValue : '');
}
/** Sets the form inputs value to match the data object provided. */
function setForm(node, data) {
    for (const el of node.elements) {
        if (isFieldSetElement(el))
            addAttrsFromFieldset(el);
        if (!isFormControl(el) || !el.name)
            continue;
        const elName = getPath(el);
        setControlValue(el, _get(data, elName));
    }
}

exports._cloneDeep = _cloneDeep;
exports._defaultsDeep = _defaultsDeep;
exports._get = _get;
exports._isPlainObject = _isPlainObject;
exports._mapValues = _mapValues;
exports._merge = _merge;
exports._mergeWith = _mergeWith;
exports._set = _set;
exports._some = _some;
exports._unset = _unset;
exports._update = _update;
exports.addAttrsFromFieldset = addAttrsFromFieldset;
exports.createId = createId;
exports.debounce = debounce;
exports.deepSet = deepSet;
exports.deepSome = deepSome;
exports.executeTransforms = executeTransforms;
exports.getFormControls = getFormControls;
exports.getFormDefaultValues = getFormDefaultValues;
exports.getInputTextOrNumber = getInputTextOrNumber;
exports.getPath = getPath;
exports.getValue = getValue;
exports.isElement = isElement;
exports.isEqual = isEqual;
exports.isFieldSetElement = isFieldSetElement;
exports.isFieldValue = isFieldValue;
exports.isFormControl = isFormControl;
exports.isInputElement = isInputElement;
exports.isSelectElement = isSelectElement;
exports.isTextAreaElement = isTextAreaElement;
exports.mergeErrors = mergeErrors;
exports.runValidations = runValidations;
exports.setControlValue = setControlValue;
exports.setForm = setForm;
exports.shouldIgnore = shouldIgnore;
//# sourceMappingURL=index.cjs.map
