import { _get, _set, _isPlainObject, deepSet, createId, setForm, _cloneDeep, _merge, deepSome, isFormControl, _update, _unset } from '@felte/common';
import { get } from './get.js';
import { deepSetTouched } from './deep-set-touched.js';
import { deepSetKey, deepRemoveKey } from './deep-set-key.js';
import { createEventConstructors } from './events.js';
import { createDefaultSubmitHandler } from './default-submit-handler.js';

function addAtIndex(storeValue, path, value, index) {
    return _update(storeValue, path, (oldValue) => {
        if (typeof oldValue !== 'undefined' && !Array.isArray(oldValue))
            return oldValue;
        if (!oldValue)
            oldValue = [];
        if (typeof index === 'undefined') {
            oldValue.push(value);
        }
        else {
            oldValue.splice(index, 0, value);
        }
        return oldValue;
    });
}
function swapInArray(storeValue, path, from, to) {
    return _update(storeValue, path, (oldValue) => {
        if (!oldValue || !Array.isArray(oldValue))
            return oldValue;
        [oldValue[from], oldValue[to]] = [oldValue[to], oldValue[from]];
        return oldValue;
    });
}
function moveInArray(storeValue, path, from, to) {
    return _update(storeValue, path, (oldValue) => {
        if (!oldValue || !Array.isArray(oldValue))
            return oldValue;
        oldValue.splice(to, 0, oldValue.splice(from, 1)[0]);
        return oldValue;
    });
}
function isUpdater(value) {
    return typeof value === 'function';
}
function createSetHelper(storeSetter) {
    const setHelper = (pathOrValue, valueOrUpdater) => {
        if (typeof pathOrValue === 'string') {
            const path = pathOrValue;
            storeSetter((oldValue) => {
                const newValue = isUpdater(valueOrUpdater)
                    ? valueOrUpdater(_get(oldValue, path))
                    : valueOrUpdater;
                return _set(oldValue, path, newValue);
            });
        }
        else {
            storeSetter((oldValue) => isUpdater(pathOrValue) ? pathOrValue(oldValue) : pathOrValue);
        }
    };
    return setHelper;
}
function createHelpers({ stores, config, validateErrors, validateWarnings, _getCurrentExtenders, }) {
    var _a;
    let formNode;
    let initialValues = deepSetKey(((_a = config.initialValues) !== null && _a !== void 0 ? _a : {}));
    const { data, touched, errors, warnings, isDirty, isSubmitting, interacted, } = stores;
    const setData = createSetHelper(data.update);
    const setTouched = createSetHelper(touched.update);
    const setErrors = createSetHelper(errors.update);
    const setWarnings = createSetHelper(warnings.update);
    function updateFields(updater) {
        setData((oldData) => {
            const newData = updater(oldData);
            if (formNode)
                setForm(formNode, newData);
            return newData;
        });
    }
    const setFields = (pathOrValue, valueOrUpdater, shouldTouch) => {
        const fieldsSetter = createSetHelper(updateFields);
        fieldsSetter(pathOrValue, valueOrUpdater);
        if (typeof pathOrValue === 'string' && shouldTouch) {
            setTouched(pathOrValue, true);
        }
    };
    function addField(path, value, index) {
        const touchedValue = _isPlainObject(value)
            ? deepSetTouched(value, false)
            : false;
        const errValue = _isPlainObject(touchedValue)
            ? deepSet(touchedValue, [])
            : [];
        value = _isPlainObject(value) ? Object.assign(Object.assign({}, value), { key: createId() }) : value;
        errors.update(($errors) => {
            return addAtIndex($errors, path, errValue, index);
        });
        warnings.update(($warnings) => {
            return addAtIndex($warnings, path, errValue, index);
        });
        touched.update(($touched) => {
            return addAtIndex($touched, path, touchedValue, index);
        });
        data.update(($data) => {
            const newData = addAtIndex($data, path, value, index);
            setTimeout(() => formNode && setForm(formNode, newData));
            return newData;
        });
    }
    function updateAll(updater) {
        errors.update(updater);
        warnings.update(updater);
        touched.update(updater);
        data.update(($data) => {
            const newData = updater($data);
            setTimeout(() => formNode && setForm(formNode, newData));
            return newData;
        });
    }
    function unsetField(path) {
        updateAll((storeValue) => _unset(storeValue, path));
    }
    function swapFields(path, from, to) {
        updateAll((storeValue) => swapInArray(storeValue, path, from, to));
    }
    function moveField(path, from, to) {
        updateAll((storeValue) => moveInArray(storeValue, path, from, to));
    }
    function resetField(path) {
        const initialValue = _get(initialValues, path);
        const touchedValue = _isPlainObject(initialValue)
            ? deepSetTouched(initialValue, false)
            : false;
        const errValue = _isPlainObject(touchedValue)
            ? deepSet(touchedValue, [])
            : [];
        data.update(($data) => {
            const newData = _set($data, path, initialValue);
            if (formNode)
                setForm(formNode, newData);
            return newData;
        });
        touched.update(($touched) => {
            return _set($touched, path, touchedValue);
        });
        errors.update(($errors) => {
            return _set($errors, path, errValue);
        });
        warnings.update(($warnings) => {
            return _set($warnings, path, errValue);
        });
    }
    const setIsSubmitting = createSetHelper(isSubmitting.update);
    const setIsDirty = createSetHelper(isDirty.update);
    const setInteracted = createSetHelper(interacted.update);
    async function validate() {
        const currentData = get(data);
        touched.set(deepSetTouched(currentData, true));
        interacted.set(null);
        const currentErrors = await validateErrors(currentData);
        await validateWarnings(currentData);
        return currentErrors;
    }
    function reset() {
        setFields(_cloneDeep(initialValues));
        setTouched(($touched) => deepSet($touched, false));
        interacted.set(null);
        isDirty.set(false);
    }
    function createSubmitHandler(altConfig) {
        return async function handleSubmit(event) {
            var _a, _b, _c, _d, _e, _f, _g;
            const { createErrorEvent, createSubmitEvent, createSuccessEvent, } = createEventConstructors();
            const submitEvent = createSubmitEvent();
            formNode === null || formNode === void 0 ? void 0 : formNode.dispatchEvent(submitEvent);
            const onError = (_b = (_a = submitEvent.onError) !== null && _a !== void 0 ? _a : altConfig === null || altConfig === void 0 ? void 0 : altConfig.onError) !== null && _b !== void 0 ? _b : config.onError;
            const onSuccess = (_d = (_c = submitEvent.onSuccess) !== null && _c !== void 0 ? _c : altConfig === null || altConfig === void 0 ? void 0 : altConfig.onSuccess) !== null && _d !== void 0 ? _d : config.onSuccess;
            const onSubmit = (_g = (_f = (_e = submitEvent.onSubmit) !== null && _e !== void 0 ? _e : altConfig === null || altConfig === void 0 ? void 0 : altConfig.onSubmit) !== null && _f !== void 0 ? _f : config.onSubmit) !== null && _g !== void 0 ? _g : createDefaultSubmitHandler(formNode);
            if (!onSubmit)
                return;
            event === null || event === void 0 ? void 0 : event.preventDefault();
            if (submitEvent.defaultPrevented)
                return;
            isSubmitting.set(true);
            interacted.set(null);
            const currentData = deepRemoveKey(get(data));
            const currentErrors = await validateErrors(currentData, altConfig === null || altConfig === void 0 ? void 0 : altConfig.validate);
            const currentWarnings = await validateWarnings(currentData, altConfig === null || altConfig === void 0 ? void 0 : altConfig.warn);
            if (currentWarnings)
                warnings.set(_merge(deepSet(currentData, []), currentWarnings));
            touched.set(deepSetTouched(currentData, true));
            if (currentErrors) {
                touched.set(deepSetTouched(currentErrors, true));
                const hasErrors = deepSome(currentErrors, (error) => Array.isArray(error) ? error.length >= 1 : !!error);
                if (hasErrors) {
                    await new Promise((r) => setTimeout(r));
                    _getCurrentExtenders().forEach((extender) => {
                        var _a;
                        return (_a = extender.onSubmitError) === null || _a === void 0 ? void 0 : _a.call(extender, {
                            data: currentData,
                            errors: currentErrors,
                        });
                    });
                    isSubmitting.set(false);
                    return;
                }
            }
            const context = {
                setFields,
                setData,
                setTouched,
                setErrors,
                setWarnings,
                unsetField,
                addField,
                resetField,
                reset,
                setInitialValues: publicHelpers.setInitialValues,
                moveField,
                swapFields,
                form: formNode,
                controls: formNode && Array.from(formNode.elements).filter(isFormControl),
                config: Object.assign(Object.assign({}, config), altConfig),
            };
            try {
                const response = await onSubmit(currentData, context);
                formNode === null || formNode === void 0 ? void 0 : formNode.dispatchEvent(createSuccessEvent(Object.assign({ response }, context)));
                await (onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess(response, context));
            }
            catch (e) {
                const errorEvent = createErrorEvent(Object.assign({ error: e }, context));
                formNode === null || formNode === void 0 ? void 0 : formNode.dispatchEvent(errorEvent);
                if (!onError && !errorEvent.defaultPrevented) {
                    throw e;
                }
                if (!onError && !errorEvent.errors)
                    return;
                const serverErrors = errorEvent.errors || (await (onError === null || onError === void 0 ? void 0 : onError(e, context)));
                if (serverErrors) {
                    touched.set(deepSetTouched(serverErrors, true));
                    errors.set(serverErrors);
                    await new Promise((r) => setTimeout(r));
                    _getCurrentExtenders().forEach((extender) => {
                        var _a;
                        return (_a = extender.onSubmitError) === null || _a === void 0 ? void 0 : _a.call(extender, {
                            data: currentData,
                            errors: get(errors),
                        });
                    });
                }
            }
            finally {
                isSubmitting.set(false);
            }
        };
    }
    const publicHelpers = {
        setData,
        setFields,
        setTouched,
        setErrors,
        setWarnings,
        setIsSubmitting,
        setIsDirty,
        setInteracted,
        validate,
        reset,
        unsetField,
        resetField,
        addField,
        swapFields,
        moveField,
        createSubmitHandler,
        handleSubmit: createSubmitHandler(),
        setInitialValues: (values) => {
            initialValues = deepSetKey(values);
        },
    };
    const privateHelpers = {
        _setFormNode(node) {
            formNode = node;
        },
        _getInitialValues: () => initialValues,
    };
    return {
        public: publicHelpers,
        private: privateHelpers,
    };
}

export { createHelpers };
//# sourceMappingURL=helpers.js.map
