import { getFormDefaultValues, _merge, _cloneDeep, debounce, _defaultsDeep, isFormControl, _get, getPath, isSelectElement, shouldIgnore, getInputTextOrNumber, _set, isInputElement, _isPlainObject, _unset, isElement, getFormControls } from '@felte/common';
import { get } from './get.js';

function createFormAction({ helpers, stores, config, extender, createSubmitHandler, handleSubmit, _setFormNode, _getInitialValues, _setCurrentExtenders, _getCurrentExtenders, }) {
    const { setFields, setTouched, reset, setInitialValues } = helpers;
    const { addValidator, addTransformer, validate } = helpers;
    const { data, errors, warnings, touched, isSubmitting, isDirty, interacted, isValid, isValidating, } = stores;
    function form(node) {
        if (!node.requestSubmit)
            node.requestSubmit = handleSubmit;
        function callExtender(stage) {
            return function (extender) {
                return extender({
                    form: node,
                    stage,
                    controls: Array.from(node.elements).filter(isFormControl),
                    data,
                    errors,
                    warnings,
                    touched,
                    isValid,
                    isValidating,
                    isSubmitting,
                    isDirty,
                    interacted,
                    config,
                    addValidator,
                    addTransformer,
                    setFields,
                    validate,
                    reset,
                    createSubmitHandler,
                    handleSubmit,
                });
            };
        }
        _setCurrentExtenders(extender.map(callExtender('MOUNT')));
        node.noValidate = !!config.validate;
        const { defaultData, defaultTouched } = getFormDefaultValues(node);
        _setFormNode(node);
        setInitialValues(_merge(_cloneDeep(defaultData), _getInitialValues()));
        setFields(_getInitialValues());
        touched.set(defaultTouched);
        function setCheckboxValues(target) {
            const elPath = getPath(target);
            const checkboxes = Array.from(node.querySelectorAll(`[name="${target.name}"]`)).filter((checkbox) => {
                if (!isFormControl(checkbox))
                    return false;
                return elPath === getPath(checkbox);
            });
            if (checkboxes.length === 0)
                return;
            if (checkboxes.length === 1) {
                return data.update(($data) => _set($data, getPath(target), target.checked));
            }
            return data.update(($data) => {
                return _set($data, getPath(target), checkboxes
                    .filter(isInputElement)
                    .filter((el) => el.checked)
                    .map((el) => el.value));
            });
        }
        function setRadioValues(target) {
            const radios = node.querySelectorAll(`[name="${target.name}"]`);
            const checkedRadio = Array.from(radios).find((el) => isInputElement(el) && el.checked);
            data.update(($data) => _set($data, getPath(target), checkedRadio === null || checkedRadio === void 0 ? void 0 : checkedRadio.value));
        }
        function setFileValue(target) {
            var _a;
            const files = Array.from((_a = target.files) !== null && _a !== void 0 ? _a : []);
            data.update(($data) => {
                return _set($data, getPath(target), target.multiple ? files : files[0]);
            });
        }
        function setSelectValue(target) {
            if (!target.multiple) {
                data.update(($data) => {
                    return _set($data, getPath(target), target.value);
                });
            }
            else {
                const selectedOptions = Array.from(target.options)
                    .filter((opt) => opt.selected)
                    .map((opt) => opt.value);
                data.update(($data) => {
                    return _set($data, getPath(target), selectedOptions);
                });
            }
        }
        function handleInput(e) {
            const target = e.target;
            if (!target ||
                !isFormControl(target) ||
                isSelectElement(target) ||
                shouldIgnore(target))
                return;
            if (['checkbox', 'radio', 'file'].includes(target.type))
                return;
            if (!target.name)
                return;
            isDirty.set(true);
            const inputValue = getInputTextOrNumber(target);
            interacted.set(target.name);
            data.update(($data) => {
                return _set($data, getPath(target), inputValue);
            });
        }
        function handleChange(e) {
            const target = e.target;
            if (!target || !isFormControl(target) || shouldIgnore(target))
                return;
            if (!target.name)
                return;
            setTouched(getPath(target), true);
            interacted.set(target.name);
            if (isSelectElement(target) ||
                ['checkbox', 'radio', 'file', 'hidden'].includes(target.type)) {
                isDirty.set(true);
            }
            if (target.type === 'hidden') {
                data.update(($data) => {
                    return _set($data, getPath(target), target.value);
                });
            }
            if (isSelectElement(target))
                setSelectValue(target);
            else if (!isInputElement(target))
                return;
            else if (target.type === 'checkbox')
                setCheckboxValues(target);
            else if (target.type === 'radio')
                setRadioValues(target);
            else if (target.type === 'file')
                setFileValue(target);
        }
        function handleBlur(e) {
            const target = e.target;
            if (!target || !isFormControl(target) || shouldIgnore(target))
                return;
            if (!target.name)
                return;
            setTouched(getPath(target), true);
            interacted.set(target.name);
        }
        function handleReset(e) {
            e.preventDefault();
            reset();
        }
        const mutationOptions = { childList: true, subtree: true };
        function unsetTaggedForRemove(formControls) {
            let currentData = get(data);
            let currentTouched = get(touched);
            let currentErrors = get(errors);
            let currentWarnings = get(warnings);
            for (const control of formControls.reverse()) {
                if (control.hasAttribute('data-felte-keep-on-remove') &&
                    control.dataset.felteKeepOnRemove !== 'false')
                    continue;
                const fieldArrayReg = /.*(\[[0-9]+\]|\.[0-9]+)\.[^.]+$/;
                let fieldName = getPath(control);
                const shape = get(touched);
                const isFieldArray = fieldArrayReg.test(fieldName);
                if (isFieldArray) {
                    const arrayPath = fieldName.split('.').slice(0, -1).join('.');
                    const valueToRemove = _get(shape, arrayPath);
                    if (_isPlainObject(valueToRemove) &&
                        Object.keys(valueToRemove).length <= 1) {
                        fieldName = arrayPath;
                    }
                }
                currentData = _unset(currentData, fieldName);
                currentTouched = _unset(currentTouched, fieldName);
                currentErrors = _unset(currentErrors, fieldName);
                currentWarnings = _unset(currentWarnings, fieldName);
            }
            data.set(currentData);
            touched.set(currentTouched);
            errors.set(currentErrors);
            warnings.set(currentWarnings);
        }
        const updateAddedNodes = debounce(() => {
            _getCurrentExtenders().forEach((extender) => { var _a; return (_a = extender.destroy) === null || _a === void 0 ? void 0 : _a.call(extender); });
            _setCurrentExtenders(extender.map(callExtender('UPDATE')));
            const { defaultData: newDefaultData, defaultTouched: newDefaultTouched, } = getFormDefaultValues(node);
            data.update(($data) => _defaultsDeep($data, newDefaultData));
            touched.update(($touched) => {
                return _defaultsDeep($touched, newDefaultTouched);
            });
            helpers.setFields(get(data));
        }, 0);
        let removedFormControls = [];
        const updateRemovedNodes = debounce(() => {
            _getCurrentExtenders().forEach((extender) => { var _a; return (_a = extender.destroy) === null || _a === void 0 ? void 0 : _a.call(extender); });
            _setCurrentExtenders(extender.map(callExtender('UPDATE')));
            unsetTaggedForRemove(removedFormControls);
            removedFormControls = [];
        }, 0);
        function handleNodeAddition(mutation) {
            const shouldUpdate = Array.from(mutation.addedNodes).some((node) => {
                if (!isElement(node))
                    return false;
                if (isFormControl(node))
                    return true;
                const formControls = getFormControls(node);
                return formControls.length > 0;
            });
            if (!shouldUpdate)
                return;
            updateAddedNodes();
        }
        function handleNodeRemoval(mutation) {
            for (const removedNode of mutation.removedNodes) {
                if (!isElement(removedNode))
                    continue;
                const formControls = getFormControls(removedNode);
                if (formControls.length === 0)
                    continue;
                removedFormControls.push(...formControls);
                updateRemovedNodes();
            }
        }
        function mutationCallback(mutationList) {
            for (const mutation of mutationList) {
                if (mutation.type !== 'childList')
                    continue;
                if (mutation.addedNodes.length > 0)
                    handleNodeAddition(mutation);
                if (mutation.removedNodes.length > 0)
                    handleNodeRemoval(mutation);
            }
        }
        const observer = new MutationObserver(mutationCallback);
        observer.observe(node, mutationOptions);
        node.addEventListener('input', handleInput);
        node.addEventListener('change', handleChange);
        node.addEventListener('focusout', handleBlur);
        node.addEventListener('submit', handleSubmit);
        node.addEventListener('reset', handleReset);
        const unsubscribeErrors = errors.subscribe(($errors) => {
            for (const el of node.elements) {
                if (!isFormControl(el) || !el.name)
                    continue;
                const fieldErrors = _get($errors, getPath(el));
                const message = Array.isArray(fieldErrors)
                    ? fieldErrors.join('\n')
                    : typeof fieldErrors === 'string'
                        ? fieldErrors
                        : undefined;
                if (message === el.dataset.felteValidationMessage)
                    continue;
                if (message) {
                    el.dataset.felteValidationMessage = message;
                    el.setAttribute('aria-invalid', 'true');
                }
                else {
                    delete el.dataset.felteValidationMessage;
                    el.removeAttribute('aria-invalid');
                }
            }
        });
        return {
            destroy() {
                observer.disconnect();
                node.removeEventListener('input', handleInput);
                node.removeEventListener('change', handleChange);
                node.removeEventListener('focusout', handleBlur);
                node.removeEventListener('submit', handleSubmit);
                node.removeEventListener('reset', handleReset);
                unsubscribeErrors();
                _getCurrentExtenders().forEach((extender) => { var _a; return (_a = extender.destroy) === null || _a === void 0 ? void 0 : _a.call(extender); });
            },
        };
    }
    return { form };
}

export { createFormAction };
//# sourceMappingURL=create-form-action.js.map
