import { executeTransforms, _cloneDeep, deepSome, deepSet, mergeErrors, debounce, _mergeWith, _isPlainObject, runValidations } from '@felte/common';
import { deepSetTouched } from './deep-set-touched.js';
import { deepSetKey, deepRemoveKey } from './deep-set-key.js';

function createValidationController(priority) {
    const signal = { aborted: false, priority };
    return {
        signal,
        abort() {
            signal.aborted = true;
        },
    };
}
function errorFilterer(touchValue, errValue) {
    if (_isPlainObject(touchValue)) {
        if (!errValue ||
            (_isPlainObject(errValue) && Object.keys(errValue).length === 0)) {
            return deepSet(touchValue, null);
        }
        return;
    }
    if (Array.isArray(touchValue)) {
        if (touchValue.some(_isPlainObject))
            return;
        const errArray = Array.isArray(errValue) ? errValue : [];
        return touchValue.map((value, index) => {
            const err = errArray[index];
            if (Array.isArray(err) && err.length === 0)
                return null;
            return (value && err) || null;
        });
    }
    if (Array.isArray(errValue) && errValue.length === 0)
        return null;
    if (Array.isArray(errValue))
        return touchValue ? errValue : null;
    return touchValue && errValue ? [errValue] : null;
}
function warningFilterer(touchValue, errValue) {
    if (_isPlainObject(touchValue)) {
        if (!errValue ||
            (_isPlainObject(errValue) && Object.keys(errValue).length === 0)) {
            return deepSet(touchValue, null);
        }
        return;
    }
    if (Array.isArray(touchValue)) {
        if (touchValue.some(_isPlainObject))
            return;
        const errArray = Array.isArray(errValue) ? errValue : [];
        return touchValue.map((_, index) => {
            const err = errArray[index];
            if (Array.isArray(err) && err.length === 0)
                return null;
            return err || null;
        });
    }
    if (Array.isArray(errValue) && errValue.length === 0)
        return null;
    if (Array.isArray(errValue))
        return errValue;
    return errValue ? [errValue] : null;
}
function filterErrors([errors, touched]) {
    return _mergeWith(touched, errors, errorFilterer);
}
function filterWarnings([errors, touched]) {
    return _mergeWith(touched, errors, warningFilterer);
}
// A `derived` store factory that can defer subscription and be constructed
// with any store factory.
function createDerivedFactory(storeFactory) {
    return function derived(storeOrStores, deriver, initialValue) {
        const stores = Array.isArray(storeOrStores)
            ? storeOrStores
            : [storeOrStores];
        const values = new Array(stores.length);
        const derivedStore = storeFactory(initialValue);
        const storeSet = derivedStore.set;
        const storeSubscribe = derivedStore.subscribe;
        let unsubscribers;
        function startStore() {
            unsubscribers = stores.map((store, index) => {
                return store.subscribe(($store) => {
                    values[index] = $store;
                    storeSet(deriver(values));
                });
            });
        }
        function stopStore() {
            unsubscribers === null || unsubscribers === void 0 ? void 0 : unsubscribers.forEach((unsub) => unsub());
        }
        derivedStore.subscribe = function subscribe(subscriber) {
            const unsubscribe = storeSubscribe(subscriber);
            return () => {
                unsubscribe();
            };
        };
        return [derivedStore, startStore, stopStore];
    };
}
function createStores(storeFactory, config) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const derived = createDerivedFactory(storeFactory);
    const initialValues = (config.initialValues = config.initialValues
        ? deepSetKey(executeTransforms(_cloneDeep(config.initialValues), config.transform))
        : {});
    const initialTouched = deepSetTouched(deepRemoveKey(initialValues), false);
    const touched = storeFactory(initialTouched);
    const validationCount = storeFactory(0);
    const [isValidating, startIsValidating, stopIsValidating] = derived([touched, validationCount], ([$touched, $validationCount]) => {
        const isTouched = deepSome($touched, (t) => !!t);
        return isTouched && $validationCount >= 1;
    }, false);
    // It is important not to destructure stores created with the factory
    // since some stores may be callable.
    delete isValidating.set;
    delete isValidating.update;
    function cancellableValidation(store) {
        let activeController;
        return async function executeValidations($data, shape, validations, priority = false) {
            if (!validations || !$data)
                return;
            let current = shape && Object.keys(shape).length > 0
                ? shape
                : deepSet($data, []);
            // Keeping a controller allows us to cancel previous asynchronous
            // validations if they've become stale.
            const controller = createValidationController(priority);
            // By assigning `priority` we can prevent specific validations
            // from being aborted. Used when submitting the form or
            // calling the `validate` helper.
            if (!(activeController === null || activeController === void 0 ? void 0 : activeController.signal.priority) || priority) {
                activeController === null || activeController === void 0 ? void 0 : activeController.abort();
                activeController = controller;
            }
            // If the current controller has priority and we're not trying to
            // override it, completely prevent validations
            if (activeController.signal.priority && !priority)
                return;
            validationCount.update((c) => c + 1);
            const results = runValidations($data, validations);
            results.forEach(async (promise) => {
                const result = await promise;
                if (controller.signal.aborted)
                    return;
                current = mergeErrors([current, result]);
                store.set(current);
            });
            await Promise.all(results);
            activeController = undefined;
            validationCount.update((c) => c - 1);
            return current;
        };
    }
    let storesShape = deepSet(initialTouched, []);
    const data = storeFactory(initialValues);
    const initialErrors = deepSet(initialTouched, []);
    const immediateErrors = storeFactory(initialErrors);
    const debouncedErrors = storeFactory(_cloneDeep(initialErrors));
    const [errors, startErrors, stopErrors] = derived([
        immediateErrors,
        debouncedErrors,
    ], mergeErrors, _cloneDeep(initialErrors));
    const initialWarnings = deepSet(initialTouched, []);
    const immediateWarnings = storeFactory(initialWarnings);
    const debouncedWarnings = storeFactory(_cloneDeep(initialWarnings));
    const [warnings, startWarnings, stopWarnings] = derived([
        immediateWarnings,
        debouncedWarnings,
    ], mergeErrors, _cloneDeep(initialWarnings));
    const [filteredErrors, startFilteredErrors, stopFilteredErrors] = derived([errors, touched], filterErrors, _cloneDeep(initialErrors));
    const [filteredWarnings, startFilteredWarnings, stopFilteredWarnings,] = derived([warnings, touched], filterWarnings, _cloneDeep(initialWarnings));
    // This is necessary since, on the first run, validations
    // have not run yet. We assume the form is not valid in the first calling
    // if there's validation functions assigned in the configuration.
    let firstCalled = false;
    const [isValid, startIsValid, stopIsValid] = derived(errors, ([$errors]) => {
        var _a;
        if (!firstCalled) {
            firstCalled = true;
            return !config.validate && !((_a = config.debounced) === null || _a === void 0 ? void 0 : _a.validate);
        }
        else {
            return !deepSome($errors, (error) => Array.isArray(error) ? error.length >= 1 : !!error);
        }
    }, !config.validate && !((_a = config.debounced) === null || _a === void 0 ? void 0 : _a.validate));
    delete isValid.set;
    delete isValid.update;
    const isSubmitting = storeFactory(false);
    const isDirty = storeFactory(false);
    const interacted = storeFactory(null);
    const validateErrors = cancellableValidation(immediateErrors);
    const validateWarnings = cancellableValidation(immediateWarnings);
    const validateDebouncedErrors = cancellableValidation(debouncedErrors);
    const validateDebouncedWarnings = cancellableValidation(debouncedWarnings);
    const _validateDebouncedErrors = debounce(validateDebouncedErrors, (_e = (_c = (_b = config.debounced) === null || _b === void 0 ? void 0 : _b.validateTimeout) !== null && _c !== void 0 ? _c : (_d = config.debounced) === null || _d === void 0 ? void 0 : _d.timeout) !== null && _e !== void 0 ? _e : 300, {
        onInit: () => {
            validationCount.update((c) => c + 1);
        },
        onEnd: () => {
            validationCount.update((c) => c - 1);
        },
    });
    const _validateDebouncedWarnings = debounce(validateDebouncedWarnings, (_j = (_g = (_f = config.debounced) === null || _f === void 0 ? void 0 : _f.warnTimeout) !== null && _g !== void 0 ? _g : (_h = config.debounced) === null || _h === void 0 ? void 0 : _h.timeout) !== null && _j !== void 0 ? _j : 300);
    async function executeErrorsValidation(data, altValidate) {
        var _a;
        const $data = deepRemoveKey(data);
        const errors = validateErrors($data, storesShape, altValidate !== null && altValidate !== void 0 ? altValidate : config.validate, true);
        if (altValidate)
            return errors;
        const debouncedErrors = validateDebouncedErrors($data, storesShape, (_a = config.debounced) === null || _a === void 0 ? void 0 : _a.validate, true);
        return mergeErrors(await Promise.all([errors, debouncedErrors]));
    }
    async function executeWarningsValidation(data, altWarn) {
        var _a;
        const $data = deepRemoveKey(data);
        const warnings = validateWarnings($data, storesShape, altWarn !== null && altWarn !== void 0 ? altWarn : config.warn, true);
        if (altWarn)
            return warnings;
        const debouncedWarnings = validateDebouncedWarnings($data, storesShape, (_a = config.debounced) === null || _a === void 0 ? void 0 : _a.warn, true);
        return mergeErrors(await Promise.all([warnings, debouncedWarnings]));
    }
    let errorsValue = initialErrors;
    let warningsValue = initialWarnings;
    function start() {
        const dataUnsubscriber = data.subscribe(($keyedData) => {
            var _a, _b;
            const $data = deepRemoveKey($keyedData);
            validateErrors($data, storesShape, config.validate);
            validateWarnings($data, storesShape, config.warn);
            _validateDebouncedErrors($data, storesShape, (_a = config.debounced) === null || _a === void 0 ? void 0 : _a.validate);
            _validateDebouncedWarnings($data, storesShape, (_b = config.debounced) === null || _b === void 0 ? void 0 : _b.warn);
        });
        const unsubscribeTouched = touched.subscribe(($touched) => {
            storesShape = deepSet($touched, []);
        });
        const unsubscribeErrors = errors.subscribe(($errors) => {
            errorsValue = $errors;
        });
        const unsubscribeWarnings = warnings.subscribe(($warnings) => {
            warningsValue = $warnings;
        });
        startErrors();
        startIsValid();
        startWarnings();
        startFilteredErrors();
        startFilteredWarnings();
        startIsValidating();
        function cleanup() {
            dataUnsubscriber();
            stopFilteredErrors();
            stopErrors();
            stopWarnings();
            stopFilteredWarnings();
            stopIsValid();
            stopIsValidating();
            unsubscribeTouched();
            unsubscribeErrors();
            unsubscribeWarnings();
        }
        return cleanup;
    }
    function publicErrorsUpdater(updater) {
        immediateErrors.set(updater(errorsValue));
        debouncedErrors.set({});
    }
    function publicWarningsUpdater(updater) {
        immediateWarnings.set(updater(warningsValue));
        debouncedWarnings.set({});
    }
    function publicErrorsSetter(value) {
        publicErrorsUpdater(() => value);
    }
    function publicWarningsSetter(value) {
        publicWarningsUpdater(() => value);
    }
    filteredErrors.set = publicErrorsSetter;
    filteredErrors.update = publicErrorsUpdater;
    filteredWarnings.set = publicWarningsSetter;
    filteredWarnings.update = publicWarningsUpdater;
    return {
        data: data,
        errors: filteredErrors,
        warnings: filteredWarnings,
        touched,
        isValid,
        isSubmitting,
        isDirty,
        isValidating,
        interacted,
        validateErrors: executeErrorsValidation,
        validateWarnings: executeWarningsValidation,
        cleanup: config.preventStoreStart ? () => undefined : start(),
        start,
    };
}

export { createDerivedFactory, createStores, errorFilterer, warningFilterer };
//# sourceMappingURL=stores.js.map
