'use strict';

var common = require('@felte/common');

function subscribe(store, ...callbacks) {
    const unsub = store.subscribe(...callbacks);
    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get(store) {
    let value = undefined;
    subscribe(store, (_) => (value = _))();
    return value;
}

class FelteSubmitError extends Error {
    constructor(message, response) {
        super(message);
        this.name = 'FelteSubmitError';
        this.response = response;
    }
}

const observerConfig = {
    attributes: true,
    attributeFilter: ['data-felte-validation-message', 'aria-invalid'],
};
function createField(nameOrConfig, config) {
    var _a, _b;
    let name;
    let defaultValue;
    let touchOnChange;
    let fieldNode;
    let control;
    let onFormReset;
    if (typeof nameOrConfig === 'string') {
        name = nameOrConfig;
        defaultValue = config === null || config === void 0 ? void 0 : config.defaultValue;
        touchOnChange = (_a = config === null || config === void 0 ? void 0 : config.touchOnChange) !== null && _a !== void 0 ? _a : false;
        onFormReset = config === null || config === void 0 ? void 0 : config.onFormReset;
    }
    else {
        name = nameOrConfig.name;
        defaultValue = nameOrConfig.defaultValue;
        touchOnChange = (_b = nameOrConfig.touchOnChange) !== null && _b !== void 0 ? _b : false;
        onFormReset = nameOrConfig === null || nameOrConfig === void 0 ? void 0 : nameOrConfig.onFormReset;
    }
    function dispatchEvent(eventType, value) {
        if (!control)
            return;
        common.setControlValue(control, value);
        const customEvent = new Event(eventType, {
            bubbles: true,
            composed: true,
        });
        control.dispatchEvent(customEvent);
    }
    function mutationCallback(mutationList) {
        mutationList.forEach(() => {
            const invalid = control.getAttribute('aria-invalid');
            if (!invalid)
                fieldNode.removeAttribute('aria-invalid');
            else
                fieldNode.setAttribute('aria-invalid', invalid);
            const validationMessage = control.getAttribute('data-felte-validation-message');
            if (!validationMessage)
                fieldNode.removeAttribute('data-felte-validation-message');
            else
                fieldNode.setAttribute('data-felte-validation-message', validationMessage);
        });
    }
    function handleReset(e) {
        if (!onFormReset)
            return;
        common.setControlValue(control, defaultValue);
        onFormReset(e);
    }
    function field(node) {
        fieldNode = node;
        let observer;
        let formElement;
        if (common.isFormControl(node)) {
            control = node;
            control.name = name;
            return {};
        }
        else {
            // This setTimeout is necessary to guarantee the node has been mounted
            let created = false;
            let destroyed = false;
            setTimeout(() => {
                if (destroyed)
                    return;
                const parent = fieldNode.parentNode;
                if (!parent || !common.isElement(parent))
                    return;
                const foundControl = parent.querySelector(`[name="${name}"]`);
                if (!foundControl || !common.isFormControl(foundControl)) {
                    const input = document.createElement('input');
                    input.type = 'hidden';
                    input.name = name;
                    parent.insertBefore(input, node.nextSibling);
                    control = input;
                    created = true;
                }
                else {
                    control = foundControl;
                }
                common.setControlValue(control, defaultValue);
                observer = new MutationObserver(mutationCallback);
                observer.observe(control, observerConfig);
                formElement = control.closest('form');
                formElement === null || formElement === void 0 ? void 0 : formElement.addEventListener('reset', handleReset);
            });
            return {
                destroy() {
                    var _a;
                    if (created)
                        (_a = control.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(control);
                    destroyed = true;
                    observer === null || observer === void 0 ? void 0 : observer.disconnect();
                    formElement === null || formElement === void 0 ? void 0 : formElement.removeEventListener('reset', handleReset);
                },
            };
        }
    }
    function onInput(value) {
        dispatchEvent(touchOnChange ? 'change' : 'input', value);
    }
    function onBlur() {
        dispatchEvent('focusout');
    }
    return {
        field,
        onInput,
        onChange: onInput,
        onBlur,
    };
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function deepSetTouched(obj, value) {
    return common._mapValues(obj, (prop) => {
        if (common._isPlainObject(prop))
            return deepSetTouched(prop, value);
        if (Array.isArray(prop)) {
            if (prop.length === 0 || prop.every((p) => typeof p === 'string'))
                return value;
            return prop.map((p) => {
                const _a = deepSetTouched(p, value), field = __rest(_a, ["key"]);
                return field;
            });
        }
        return value;
    });
}

function deepSetKey(obj) {
    if (!obj)
        return {};
    return common._mapValues(obj, (prop) => {
        if (common._isPlainObject(prop))
            return deepSetKey(prop);
        if (Array.isArray(prop)) {
            if (prop.length === 0 || prop.every((p) => typeof p === 'string'))
                return prop;
            return prop.map((p) => {
                if (!common._isPlainObject(p))
                    return p;
                const field = deepSetKey(p);
                if (!field.key)
                    field.key = common.createId();
                return field;
            });
        }
        return prop;
    });
}
function deepRemoveKey(obj) {
    if (!obj)
        return {};
    return common._mapValues(obj, (prop) => {
        if (common._isPlainObject(prop))
            return deepSetKey(prop);
        if (Array.isArray(prop)) {
            if (prop.length === 0 || prop.every((p) => typeof p === 'string'))
                return prop;
            return prop.map((p) => {
                if (!common._isPlainObject(p))
                    return p;
                const _a = deepSetKey(p), field = __rest(_a, ["key"]);
                return field;
            });
        }
        return prop;
    });
}

function createEventConstructors() {
    class SuccessEvent extends CustomEvent {
        constructor(detail) {
            super('feltesuccess', { detail });
        }
    }
    class ErrorEvent extends CustomEvent {
        constructor(detail) {
            super('felteerror', { detail, cancelable: true });
        }
        setErrors(errors) {
            this.preventDefault();
            this.errors = errors;
        }
    }
    class SubmitEvent extends Event {
        constructor() {
            super('feltesubmit', { cancelable: true });
        }
        handleSubmit(onSubmit) {
            this.onSubmit = onSubmit;
        }
        handleError(onError) {
            this.onError = onError;
        }
        handleSuccess(onSuccess) {
            this.onSuccess = onSuccess;
        }
    }
    return {
        createErrorEvent: (detail) => new ErrorEvent(detail),
        createSubmitEvent: () => new SubmitEvent(),
        createSuccessEvent: (detail) => new SuccessEvent(detail),
    };
}

function createDefaultSubmitHandler(form) {
    if (!form)
        return;
    return async function onSubmit() {
        let body = new FormData(form);
        const action = new URL(form.action);
        const method = form.method.toLowerCase() === 'get'
            ? 'get'
            : action.searchParams.get('_method') || form.method;
        let enctype = form.enctype;
        if (form.querySelector('input[type="file"]')) {
            enctype = 'multipart/form-data';
        }
        if (method === 'get' || enctype === 'application/x-www-form-urlencoded') {
            body = new URLSearchParams(body);
        }
        let fetchOptions;
        if (method === 'get') {
            body.forEach((value, key) => {
                action.searchParams.append(key, value);
            });
            fetchOptions = { method, headers: { Accept: 'application/json' } };
        }
        else {
            fetchOptions = {
                method,
                body,
                headers: Object.assign(Object.assign({}, (enctype !== 'multipart/form-data' && {
                    'Content-Type': enctype,
                })), { Accept: 'application/json' }),
            };
        }
        const response = await window.fetch(action.toString(), fetchOptions);
        if (response.ok)
            return response;
        throw new FelteSubmitError('An error occurred while submitting the form', response);
    };
}

function addAtIndex(storeValue, path, value, index) {
    return common._update(storeValue, path, (oldValue) => {
        if (typeof oldValue !== 'undefined' && !Array.isArray(oldValue))
            return oldValue;
        if (!oldValue)
            oldValue = [];
        if (typeof index === 'undefined') {
            oldValue.push(value);
        }
        else {
            oldValue.splice(index, 0, value);
        }
        return oldValue;
    });
}
function swapInArray(storeValue, path, from, to) {
    return common._update(storeValue, path, (oldValue) => {
        if (!oldValue || !Array.isArray(oldValue))
            return oldValue;
        [oldValue[from], oldValue[to]] = [oldValue[to], oldValue[from]];
        return oldValue;
    });
}
function moveInArray(storeValue, path, from, to) {
    return common._update(storeValue, path, (oldValue) => {
        if (!oldValue || !Array.isArray(oldValue))
            return oldValue;
        oldValue.splice(to, 0, oldValue.splice(from, 1)[0]);
        return oldValue;
    });
}
function isUpdater(value) {
    return typeof value === 'function';
}
function createSetHelper(storeSetter) {
    const setHelper = (pathOrValue, valueOrUpdater) => {
        if (typeof pathOrValue === 'string') {
            const path = pathOrValue;
            storeSetter((oldValue) => {
                const newValue = isUpdater(valueOrUpdater)
                    ? valueOrUpdater(common._get(oldValue, path))
                    : valueOrUpdater;
                return common._set(oldValue, path, newValue);
            });
        }
        else {
            storeSetter((oldValue) => isUpdater(pathOrValue) ? pathOrValue(oldValue) : pathOrValue);
        }
    };
    return setHelper;
}
function createHelpers({ stores, config, validateErrors, validateWarnings, _getCurrentExtenders, }) {
    var _a;
    let formNode;
    let initialValues = deepSetKey(((_a = config.initialValues) !== null && _a !== void 0 ? _a : {}));
    const { data, touched, errors, warnings, isDirty, isSubmitting, interacted, } = stores;
    const setData = createSetHelper(data.update);
    const setTouched = createSetHelper(touched.update);
    const setErrors = createSetHelper(errors.update);
    const setWarnings = createSetHelper(warnings.update);
    function updateFields(updater) {
        setData((oldData) => {
            const newData = updater(oldData);
            if (formNode)
                common.setForm(formNode, newData);
            return newData;
        });
    }
    const setFields = (pathOrValue, valueOrUpdater, shouldTouch) => {
        const fieldsSetter = createSetHelper(updateFields);
        fieldsSetter(pathOrValue, valueOrUpdater);
        if (typeof pathOrValue === 'string' && shouldTouch) {
            setTouched(pathOrValue, true);
        }
    };
    function addField(path, value, index) {
        const touchedValue = common._isPlainObject(value)
            ? deepSetTouched(value, false)
            : false;
        const errValue = common._isPlainObject(touchedValue)
            ? common.deepSet(touchedValue, [])
            : [];
        value = common._isPlainObject(value) ? Object.assign(Object.assign({}, value), { key: common.createId() }) : value;
        errors.update(($errors) => {
            return addAtIndex($errors, path, errValue, index);
        });
        warnings.update(($warnings) => {
            return addAtIndex($warnings, path, errValue, index);
        });
        touched.update(($touched) => {
            return addAtIndex($touched, path, touchedValue, index);
        });
        data.update(($data) => {
            const newData = addAtIndex($data, path, value, index);
            setTimeout(() => formNode && common.setForm(formNode, newData));
            return newData;
        });
    }
    function updateAll(updater) {
        errors.update(updater);
        warnings.update(updater);
        touched.update(updater);
        data.update(($data) => {
            const newData = updater($data);
            setTimeout(() => formNode && common.setForm(formNode, newData));
            return newData;
        });
    }
    function unsetField(path) {
        updateAll((storeValue) => common._unset(storeValue, path));
    }
    function swapFields(path, from, to) {
        updateAll((storeValue) => swapInArray(storeValue, path, from, to));
    }
    function moveField(path, from, to) {
        updateAll((storeValue) => moveInArray(storeValue, path, from, to));
    }
    function resetField(path) {
        const initialValue = common._get(initialValues, path);
        const touchedValue = common._isPlainObject(initialValue)
            ? deepSetTouched(initialValue, false)
            : false;
        const errValue = common._isPlainObject(touchedValue)
            ? common.deepSet(touchedValue, [])
            : [];
        data.update(($data) => {
            const newData = common._set($data, path, initialValue);
            if (formNode)
                common.setForm(formNode, newData);
            return newData;
        });
        touched.update(($touched) => {
            return common._set($touched, path, touchedValue);
        });
        errors.update(($errors) => {
            return common._set($errors, path, errValue);
        });
        warnings.update(($warnings) => {
            return common._set($warnings, path, errValue);
        });
    }
    const setIsSubmitting = createSetHelper(isSubmitting.update);
    const setIsDirty = createSetHelper(isDirty.update);
    const setInteracted = createSetHelper(interacted.update);
    async function validate() {
        const currentData = get(data);
        touched.set(deepSetTouched(currentData, true));
        interacted.set(null);
        const currentErrors = await validateErrors(currentData);
        await validateWarnings(currentData);
        return currentErrors;
    }
    function reset() {
        setFields(common._cloneDeep(initialValues));
        setTouched(($touched) => common.deepSet($touched, false));
        interacted.set(null);
        isDirty.set(false);
    }
    function createSubmitHandler(altConfig) {
        return async function handleSubmit(event) {
            var _a, _b, _c, _d, _e, _f, _g;
            const { createErrorEvent, createSubmitEvent, createSuccessEvent, } = createEventConstructors();
            const submitEvent = createSubmitEvent();
            formNode === null || formNode === void 0 ? void 0 : formNode.dispatchEvent(submitEvent);
            const onError = (_b = (_a = submitEvent.onError) !== null && _a !== void 0 ? _a : altConfig === null || altConfig === void 0 ? void 0 : altConfig.onError) !== null && _b !== void 0 ? _b : config.onError;
            const onSuccess = (_d = (_c = submitEvent.onSuccess) !== null && _c !== void 0 ? _c : altConfig === null || altConfig === void 0 ? void 0 : altConfig.onSuccess) !== null && _d !== void 0 ? _d : config.onSuccess;
            const onSubmit = (_g = (_f = (_e = submitEvent.onSubmit) !== null && _e !== void 0 ? _e : altConfig === null || altConfig === void 0 ? void 0 : altConfig.onSubmit) !== null && _f !== void 0 ? _f : config.onSubmit) !== null && _g !== void 0 ? _g : createDefaultSubmitHandler(formNode);
            if (!onSubmit)
                return;
            event === null || event === void 0 ? void 0 : event.preventDefault();
            if (submitEvent.defaultPrevented)
                return;
            isSubmitting.set(true);
            interacted.set(null);
            const currentData = deepRemoveKey(get(data));
            const currentErrors = await validateErrors(currentData, altConfig === null || altConfig === void 0 ? void 0 : altConfig.validate);
            const currentWarnings = await validateWarnings(currentData, altConfig === null || altConfig === void 0 ? void 0 : altConfig.warn);
            if (currentWarnings)
                warnings.set(common._merge(common.deepSet(currentData, []), currentWarnings));
            touched.set(deepSetTouched(currentData, true));
            if (currentErrors) {
                touched.set(deepSetTouched(currentErrors, true));
                const hasErrors = common.deepSome(currentErrors, (error) => Array.isArray(error) ? error.length >= 1 : !!error);
                if (hasErrors) {
                    await new Promise((r) => setTimeout(r));
                    _getCurrentExtenders().forEach((extender) => {
                        var _a;
                        return (_a = extender.onSubmitError) === null || _a === void 0 ? void 0 : _a.call(extender, {
                            data: currentData,
                            errors: currentErrors,
                        });
                    });
                    isSubmitting.set(false);
                    return;
                }
            }
            const context = {
                setFields,
                setData,
                setTouched,
                setErrors,
                setWarnings,
                unsetField,
                addField,
                resetField,
                reset,
                setInitialValues: publicHelpers.setInitialValues,
                moveField,
                swapFields,
                form: formNode,
                controls: formNode && Array.from(formNode.elements).filter(common.isFormControl),
                config: Object.assign(Object.assign({}, config), altConfig),
            };
            try {
                const response = await onSubmit(currentData, context);
                formNode === null || formNode === void 0 ? void 0 : formNode.dispatchEvent(createSuccessEvent(Object.assign({ response }, context)));
                await (onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess(response, context));
            }
            catch (e) {
                const errorEvent = createErrorEvent(Object.assign({ error: e }, context));
                formNode === null || formNode === void 0 ? void 0 : formNode.dispatchEvent(errorEvent);
                if (!onError && !errorEvent.defaultPrevented) {
                    throw e;
                }
                if (!onError && !errorEvent.errors)
                    return;
                const serverErrors = errorEvent.errors || (await (onError === null || onError === void 0 ? void 0 : onError(e, context)));
                if (serverErrors) {
                    touched.set(deepSetTouched(serverErrors, true));
                    errors.set(serverErrors);
                    await new Promise((r) => setTimeout(r));
                    _getCurrentExtenders().forEach((extender) => {
                        var _a;
                        return (_a = extender.onSubmitError) === null || _a === void 0 ? void 0 : _a.call(extender, {
                            data: currentData,
                            errors: get(errors),
                        });
                    });
                }
            }
            finally {
                isSubmitting.set(false);
            }
        };
    }
    const publicHelpers = {
        setData,
        setFields,
        setTouched,
        setErrors,
        setWarnings,
        setIsSubmitting,
        setIsDirty,
        setInteracted,
        validate,
        reset,
        unsetField,
        resetField,
        addField,
        swapFields,
        moveField,
        createSubmitHandler,
        handleSubmit: createSubmitHandler(),
        setInitialValues: (values) => {
            initialValues = deepSetKey(values);
        },
    };
    const privateHelpers = {
        _setFormNode(node) {
            formNode = node;
        },
        _getInitialValues: () => initialValues,
    };
    return {
        public: publicHelpers,
        private: privateHelpers,
    };
}

function createFormAction({ helpers, stores, config, extender, createSubmitHandler, handleSubmit, _setFormNode, _getInitialValues, _setCurrentExtenders, _getCurrentExtenders, }) {
    const { setFields, setTouched, reset, setInitialValues } = helpers;
    const { addValidator, addTransformer, validate } = helpers;
    const { data, errors, warnings, touched, isSubmitting, isDirty, interacted, isValid, isValidating, } = stores;
    function form(node) {
        if (!node.requestSubmit)
            node.requestSubmit = handleSubmit;
        function callExtender(stage) {
            return function (extender) {
                return extender({
                    form: node,
                    stage,
                    controls: Array.from(node.elements).filter(common.isFormControl),
                    data,
                    errors,
                    warnings,
                    touched,
                    isValid,
                    isValidating,
                    isSubmitting,
                    isDirty,
                    interacted,
                    config,
                    addValidator,
                    addTransformer,
                    setFields,
                    validate,
                    reset,
                    createSubmitHandler,
                    handleSubmit,
                });
            };
        }
        _setCurrentExtenders(extender.map(callExtender('MOUNT')));
        node.noValidate = !!config.validate;
        const { defaultData, defaultTouched } = common.getFormDefaultValues(node);
        _setFormNode(node);
        setInitialValues(common._merge(common._cloneDeep(defaultData), _getInitialValues()));
        setFields(_getInitialValues());
        touched.set(defaultTouched);
        function setCheckboxValues(target) {
            const elPath = common.getPath(target);
            const checkboxes = Array.from(node.querySelectorAll(`[name="${target.name}"]`)).filter((checkbox) => {
                if (!common.isFormControl(checkbox))
                    return false;
                return elPath === common.getPath(checkbox);
            });
            if (checkboxes.length === 0)
                return;
            if (checkboxes.length === 1) {
                return data.update(($data) => common._set($data, common.getPath(target), target.checked));
            }
            return data.update(($data) => {
                return common._set($data, common.getPath(target), checkboxes
                    .filter(common.isInputElement)
                    .filter((el) => el.checked)
                    .map((el) => el.value));
            });
        }
        function setRadioValues(target) {
            const radios = node.querySelectorAll(`[name="${target.name}"]`);
            const checkedRadio = Array.from(radios).find((el) => common.isInputElement(el) && el.checked);
            data.update(($data) => common._set($data, common.getPath(target), checkedRadio === null || checkedRadio === void 0 ? void 0 : checkedRadio.value));
        }
        function setFileValue(target) {
            var _a;
            const files = Array.from((_a = target.files) !== null && _a !== void 0 ? _a : []);
            data.update(($data) => {
                return common._set($data, common.getPath(target), target.multiple ? files : files[0]);
            });
        }
        function setSelectValue(target) {
            if (!target.multiple) {
                data.update(($data) => {
                    return common._set($data, common.getPath(target), target.value);
                });
            }
            else {
                const selectedOptions = Array.from(target.options)
                    .filter((opt) => opt.selected)
                    .map((opt) => opt.value);
                data.update(($data) => {
                    return common._set($data, common.getPath(target), selectedOptions);
                });
            }
        }
        function handleInput(e) {
            const target = e.target;
            if (!target ||
                !common.isFormControl(target) ||
                common.isSelectElement(target) ||
                common.shouldIgnore(target))
                return;
            if (['checkbox', 'radio', 'file'].includes(target.type))
                return;
            if (!target.name)
                return;
            isDirty.set(true);
            const inputValue = common.getInputTextOrNumber(target);
            interacted.set(target.name);
            data.update(($data) => {
                return common._set($data, common.getPath(target), inputValue);
            });
        }
        function handleChange(e) {
            const target = e.target;
            if (!target || !common.isFormControl(target) || common.shouldIgnore(target))
                return;
            if (!target.name)
                return;
            setTouched(common.getPath(target), true);
            interacted.set(target.name);
            if (common.isSelectElement(target) ||
                ['checkbox', 'radio', 'file', 'hidden'].includes(target.type)) {
                isDirty.set(true);
            }
            if (target.type === 'hidden') {
                data.update(($data) => {
                    return common._set($data, common.getPath(target), target.value);
                });
            }
            if (common.isSelectElement(target))
                setSelectValue(target);
            else if (!common.isInputElement(target))
                return;
            else if (target.type === 'checkbox')
                setCheckboxValues(target);
            else if (target.type === 'radio')
                setRadioValues(target);
            else if (target.type === 'file')
                setFileValue(target);
        }
        function handleBlur(e) {
            const target = e.target;
            if (!target || !common.isFormControl(target) || common.shouldIgnore(target))
                return;
            if (!target.name)
                return;
            setTouched(common.getPath(target), true);
            interacted.set(target.name);
        }
        function handleReset(e) {
            e.preventDefault();
            reset();
        }
        const mutationOptions = { childList: true, subtree: true };
        function unsetTaggedForRemove(formControls) {
            let currentData = get(data);
            let currentTouched = get(touched);
            let currentErrors = get(errors);
            let currentWarnings = get(warnings);
            for (const control of formControls.reverse()) {
                if (control.hasAttribute('data-felte-keep-on-remove') &&
                    control.dataset.felteKeepOnRemove !== 'false')
                    continue;
                const fieldArrayReg = /.*(\[[0-9]+\]|\.[0-9]+)\.[^.]+$/;
                let fieldName = common.getPath(control);
                const shape = get(touched);
                const isFieldArray = fieldArrayReg.test(fieldName);
                if (isFieldArray) {
                    const arrayPath = fieldName.split('.').slice(0, -1).join('.');
                    const valueToRemove = common._get(shape, arrayPath);
                    if (common._isPlainObject(valueToRemove) &&
                        Object.keys(valueToRemove).length <= 1) {
                        fieldName = arrayPath;
                    }
                }
                currentData = common._unset(currentData, fieldName);
                currentTouched = common._unset(currentTouched, fieldName);
                currentErrors = common._unset(currentErrors, fieldName);
                currentWarnings = common._unset(currentWarnings, fieldName);
            }
            data.set(currentData);
            touched.set(currentTouched);
            errors.set(currentErrors);
            warnings.set(currentWarnings);
        }
        const updateAddedNodes = common.debounce(() => {
            _getCurrentExtenders().forEach((extender) => { var _a; return (_a = extender.destroy) === null || _a === void 0 ? void 0 : _a.call(extender); });
            _setCurrentExtenders(extender.map(callExtender('UPDATE')));
            const { defaultData: newDefaultData, defaultTouched: newDefaultTouched, } = common.getFormDefaultValues(node);
            data.update(($data) => common._defaultsDeep($data, newDefaultData));
            touched.update(($touched) => {
                return common._defaultsDeep($touched, newDefaultTouched);
            });
            helpers.setFields(get(data));
        }, 0);
        let removedFormControls = [];
        const updateRemovedNodes = common.debounce(() => {
            _getCurrentExtenders().forEach((extender) => { var _a; return (_a = extender.destroy) === null || _a === void 0 ? void 0 : _a.call(extender); });
            _setCurrentExtenders(extender.map(callExtender('UPDATE')));
            unsetTaggedForRemove(removedFormControls);
            removedFormControls = [];
        }, 0);
        function handleNodeAddition(mutation) {
            const shouldUpdate = Array.from(mutation.addedNodes).some((node) => {
                if (!common.isElement(node))
                    return false;
                if (common.isFormControl(node))
                    return true;
                const formControls = common.getFormControls(node);
                return formControls.length > 0;
            });
            if (!shouldUpdate)
                return;
            updateAddedNodes();
        }
        function handleNodeRemoval(mutation) {
            for (const removedNode of mutation.removedNodes) {
                if (!common.isElement(removedNode))
                    continue;
                const formControls = common.getFormControls(removedNode);
                if (formControls.length === 0)
                    continue;
                removedFormControls.push(...formControls);
                updateRemovedNodes();
            }
        }
        function mutationCallback(mutationList) {
            for (const mutation of mutationList) {
                if (mutation.type !== 'childList')
                    continue;
                if (mutation.addedNodes.length > 0)
                    handleNodeAddition(mutation);
                if (mutation.removedNodes.length > 0)
                    handleNodeRemoval(mutation);
            }
        }
        const observer = new MutationObserver(mutationCallback);
        observer.observe(node, mutationOptions);
        node.addEventListener('input', handleInput);
        node.addEventListener('change', handleChange);
        node.addEventListener('focusout', handleBlur);
        node.addEventListener('submit', handleSubmit);
        node.addEventListener('reset', handleReset);
        const unsubscribeErrors = errors.subscribe(($errors) => {
            for (const el of node.elements) {
                if (!common.isFormControl(el) || !el.name)
                    continue;
                const fieldErrors = common._get($errors, common.getPath(el));
                const message = Array.isArray(fieldErrors)
                    ? fieldErrors.join('\n')
                    : typeof fieldErrors === 'string'
                        ? fieldErrors
                        : undefined;
                if (message === el.dataset.felteValidationMessage)
                    continue;
                if (message) {
                    el.dataset.felteValidationMessage = message;
                    el.setAttribute('aria-invalid', 'true');
                }
                else {
                    delete el.dataset.felteValidationMessage;
                    el.removeAttribute('aria-invalid');
                }
            }
        });
        return {
            destroy() {
                observer.disconnect();
                node.removeEventListener('input', handleInput);
                node.removeEventListener('change', handleChange);
                node.removeEventListener('focusout', handleBlur);
                node.removeEventListener('submit', handleSubmit);
                node.removeEventListener('reset', handleReset);
                unsubscribeErrors();
                _getCurrentExtenders().forEach((extender) => { var _a; return (_a = extender.destroy) === null || _a === void 0 ? void 0 : _a.call(extender); });
            },
        };
    }
    return { form };
}

function createValidationController(priority) {
    const signal = { aborted: false, priority };
    return {
        signal,
        abort() {
            signal.aborted = true;
        },
    };
}
function errorFilterer(touchValue, errValue) {
    if (common._isPlainObject(touchValue)) {
        if (!errValue ||
            (common._isPlainObject(errValue) && Object.keys(errValue).length === 0)) {
            return common.deepSet(touchValue, null);
        }
        return;
    }
    if (Array.isArray(touchValue)) {
        if (touchValue.some(common._isPlainObject))
            return;
        const errArray = Array.isArray(errValue) ? errValue : [];
        return touchValue.map((value, index) => {
            const err = errArray[index];
            if (Array.isArray(err) && err.length === 0)
                return null;
            return (value && err) || null;
        });
    }
    if (Array.isArray(errValue) && errValue.length === 0)
        return null;
    if (Array.isArray(errValue))
        return touchValue ? errValue : null;
    return touchValue && errValue ? [errValue] : null;
}
function warningFilterer(touchValue, errValue) {
    if (common._isPlainObject(touchValue)) {
        if (!errValue ||
            (common._isPlainObject(errValue) && Object.keys(errValue).length === 0)) {
            return common.deepSet(touchValue, null);
        }
        return;
    }
    if (Array.isArray(touchValue)) {
        if (touchValue.some(common._isPlainObject))
            return;
        const errArray = Array.isArray(errValue) ? errValue : [];
        return touchValue.map((_, index) => {
            const err = errArray[index];
            if (Array.isArray(err) && err.length === 0)
                return null;
            return err || null;
        });
    }
    if (Array.isArray(errValue) && errValue.length === 0)
        return null;
    if (Array.isArray(errValue))
        return errValue;
    return errValue ? [errValue] : null;
}
function filterErrors([errors, touched]) {
    return common._mergeWith(touched, errors, errorFilterer);
}
function filterWarnings([errors, touched]) {
    return common._mergeWith(touched, errors, warningFilterer);
}
// A `derived` store factory that can defer subscription and be constructed
// with any store factory.
function createDerivedFactory(storeFactory) {
    return function derived(storeOrStores, deriver, initialValue) {
        const stores = Array.isArray(storeOrStores)
            ? storeOrStores
            : [storeOrStores];
        const values = new Array(stores.length);
        const derivedStore = storeFactory(initialValue);
        const storeSet = derivedStore.set;
        const storeSubscribe = derivedStore.subscribe;
        let unsubscribers;
        function startStore() {
            unsubscribers = stores.map((store, index) => {
                return store.subscribe(($store) => {
                    values[index] = $store;
                    storeSet(deriver(values));
                });
            });
        }
        function stopStore() {
            unsubscribers === null || unsubscribers === void 0 ? void 0 : unsubscribers.forEach((unsub) => unsub());
        }
        derivedStore.subscribe = function subscribe(subscriber) {
            const unsubscribe = storeSubscribe(subscriber);
            return () => {
                unsubscribe();
            };
        };
        return [derivedStore, startStore, stopStore];
    };
}
function createStores(storeFactory, config) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const derived = createDerivedFactory(storeFactory);
    const initialValues = (config.initialValues = config.initialValues
        ? deepSetKey(common.executeTransforms(common._cloneDeep(config.initialValues), config.transform))
        : {});
    const initialTouched = deepSetTouched(deepRemoveKey(initialValues), false);
    const touched = storeFactory(initialTouched);
    const validationCount = storeFactory(0);
    const [isValidating, startIsValidating, stopIsValidating] = derived([touched, validationCount], ([$touched, $validationCount]) => {
        const isTouched = common.deepSome($touched, (t) => !!t);
        return isTouched && $validationCount >= 1;
    }, false);
    // It is important not to destructure stores created with the factory
    // since some stores may be callable.
    delete isValidating.set;
    delete isValidating.update;
    function cancellableValidation(store) {
        let activeController;
        return async function executeValidations($data, shape, validations, priority = false) {
            if (!validations || !$data)
                return;
            let current = shape && Object.keys(shape).length > 0
                ? shape
                : common.deepSet($data, []);
            // Keeping a controller allows us to cancel previous asynchronous
            // validations if they've become stale.
            const controller = createValidationController(priority);
            // By assigning `priority` we can prevent specific validations
            // from being aborted. Used when submitting the form or
            // calling the `validate` helper.
            if (!(activeController === null || activeController === void 0 ? void 0 : activeController.signal.priority) || priority) {
                activeController === null || activeController === void 0 ? void 0 : activeController.abort();
                activeController = controller;
            }
            // If the current controller has priority and we're not trying to
            // override it, completely prevent validations
            if (activeController.signal.priority && !priority)
                return;
            validationCount.update((c) => c + 1);
            const results = common.runValidations($data, validations);
            results.forEach(async (promise) => {
                const result = await promise;
                if (controller.signal.aborted)
                    return;
                current = common.mergeErrors([current, result]);
                store.set(current);
            });
            await Promise.all(results);
            activeController = undefined;
            validationCount.update((c) => c - 1);
            return current;
        };
    }
    let storesShape = common.deepSet(initialTouched, []);
    const data = storeFactory(initialValues);
    const initialErrors = common.deepSet(initialTouched, []);
    const immediateErrors = storeFactory(initialErrors);
    const debouncedErrors = storeFactory(common._cloneDeep(initialErrors));
    const [errors, startErrors, stopErrors] = derived([
        immediateErrors,
        debouncedErrors,
    ], common.mergeErrors, common._cloneDeep(initialErrors));
    const initialWarnings = common.deepSet(initialTouched, []);
    const immediateWarnings = storeFactory(initialWarnings);
    const debouncedWarnings = storeFactory(common._cloneDeep(initialWarnings));
    const [warnings, startWarnings, stopWarnings] = derived([
        immediateWarnings,
        debouncedWarnings,
    ], common.mergeErrors, common._cloneDeep(initialWarnings));
    const [filteredErrors, startFilteredErrors, stopFilteredErrors] = derived([errors, touched], filterErrors, common._cloneDeep(initialErrors));
    const [filteredWarnings, startFilteredWarnings, stopFilteredWarnings,] = derived([warnings, touched], filterWarnings, common._cloneDeep(initialWarnings));
    // This is necessary since, on the first run, validations
    // have not run yet. We assume the form is not valid in the first calling
    // if there's validation functions assigned in the configuration.
    let firstCalled = false;
    const [isValid, startIsValid, stopIsValid] = derived(errors, ([$errors]) => {
        var _a;
        if (!firstCalled) {
            firstCalled = true;
            return !config.validate && !((_a = config.debounced) === null || _a === void 0 ? void 0 : _a.validate);
        }
        else {
            return !common.deepSome($errors, (error) => Array.isArray(error) ? error.length >= 1 : !!error);
        }
    }, !config.validate && !((_a = config.debounced) === null || _a === void 0 ? void 0 : _a.validate));
    delete isValid.set;
    delete isValid.update;
    const isSubmitting = storeFactory(false);
    const isDirty = storeFactory(false);
    const interacted = storeFactory(null);
    const validateErrors = cancellableValidation(immediateErrors);
    const validateWarnings = cancellableValidation(immediateWarnings);
    const validateDebouncedErrors = cancellableValidation(debouncedErrors);
    const validateDebouncedWarnings = cancellableValidation(debouncedWarnings);
    const _validateDebouncedErrors = common.debounce(validateDebouncedErrors, (_e = (_c = (_b = config.debounced) === null || _b === void 0 ? void 0 : _b.validateTimeout) !== null && _c !== void 0 ? _c : (_d = config.debounced) === null || _d === void 0 ? void 0 : _d.timeout) !== null && _e !== void 0 ? _e : 300, {
        onInit: () => {
            validationCount.update((c) => c + 1);
        },
        onEnd: () => {
            validationCount.update((c) => c - 1);
        },
    });
    const _validateDebouncedWarnings = common.debounce(validateDebouncedWarnings, (_j = (_g = (_f = config.debounced) === null || _f === void 0 ? void 0 : _f.warnTimeout) !== null && _g !== void 0 ? _g : (_h = config.debounced) === null || _h === void 0 ? void 0 : _h.timeout) !== null && _j !== void 0 ? _j : 300);
    async function executeErrorsValidation(data, altValidate) {
        var _a;
        const $data = deepRemoveKey(data);
        const errors = validateErrors($data, storesShape, altValidate !== null && altValidate !== void 0 ? altValidate : config.validate, true);
        if (altValidate)
            return errors;
        const debouncedErrors = validateDebouncedErrors($data, storesShape, (_a = config.debounced) === null || _a === void 0 ? void 0 : _a.validate, true);
        return common.mergeErrors(await Promise.all([errors, debouncedErrors]));
    }
    async function executeWarningsValidation(data, altWarn) {
        var _a;
        const $data = deepRemoveKey(data);
        const warnings = validateWarnings($data, storesShape, altWarn !== null && altWarn !== void 0 ? altWarn : config.warn, true);
        if (altWarn)
            return warnings;
        const debouncedWarnings = validateDebouncedWarnings($data, storesShape, (_a = config.debounced) === null || _a === void 0 ? void 0 : _a.warn, true);
        return common.mergeErrors(await Promise.all([warnings, debouncedWarnings]));
    }
    let errorsValue = initialErrors;
    let warningsValue = initialWarnings;
    function start() {
        const dataUnsubscriber = data.subscribe(($keyedData) => {
            var _a, _b;
            const $data = deepRemoveKey($keyedData);
            validateErrors($data, storesShape, config.validate);
            validateWarnings($data, storesShape, config.warn);
            _validateDebouncedErrors($data, storesShape, (_a = config.debounced) === null || _a === void 0 ? void 0 : _a.validate);
            _validateDebouncedWarnings($data, storesShape, (_b = config.debounced) === null || _b === void 0 ? void 0 : _b.warn);
        });
        const unsubscribeTouched = touched.subscribe(($touched) => {
            storesShape = common.deepSet($touched, []);
        });
        const unsubscribeErrors = errors.subscribe(($errors) => {
            errorsValue = $errors;
        });
        const unsubscribeWarnings = warnings.subscribe(($warnings) => {
            warningsValue = $warnings;
        });
        startErrors();
        startIsValid();
        startWarnings();
        startFilteredErrors();
        startFilteredWarnings();
        startIsValidating();
        function cleanup() {
            dataUnsubscriber();
            stopFilteredErrors();
            stopErrors();
            stopWarnings();
            stopFilteredWarnings();
            stopIsValid();
            stopIsValidating();
            unsubscribeTouched();
            unsubscribeErrors();
            unsubscribeWarnings();
        }
        return cleanup;
    }
    function publicErrorsUpdater(updater) {
        immediateErrors.set(updater(errorsValue));
        debouncedErrors.set({});
    }
    function publicWarningsUpdater(updater) {
        immediateWarnings.set(updater(warningsValue));
        debouncedWarnings.set({});
    }
    function publicErrorsSetter(value) {
        publicErrorsUpdater(() => value);
    }
    function publicWarningsSetter(value) {
        publicWarningsUpdater(() => value);
    }
    filteredErrors.set = publicErrorsSetter;
    filteredErrors.update = publicErrorsUpdater;
    filteredWarnings.set = publicWarningsSetter;
    filteredWarnings.update = publicWarningsUpdater;
    return {
        data: data,
        errors: filteredErrors,
        warnings: filteredWarnings,
        touched,
        isValid,
        isSubmitting,
        isDirty,
        isValidating,
        interacted,
        validateErrors: executeErrorsValidation,
        validateWarnings: executeWarningsValidation,
        cleanup: config.preventStoreStart ? () => undefined : start(),
        start,
    };
}

function createForm(config, adapters) {
    var _a, _b;
    (_a = config.extend) !== null && _a !== void 0 ? _a : (config.extend = []);
    (_b = config.debounced) !== null && _b !== void 0 ? _b : (config.debounced = {});
    if (config.validate && !Array.isArray(config.validate))
        config.validate = [config.validate];
    if (config.debounced.validate && !Array.isArray(config.debounced.validate))
        config.debounced.validate = [config.debounced.validate];
    if (config.transform && !Array.isArray(config.transform))
        config.transform = [config.transform];
    if (config.warn && !Array.isArray(config.warn))
        config.warn = [config.warn];
    if (config.debounced.warn && !Array.isArray(config.debounced.warn))
        config.debounced.warn = [config.debounced.warn];
    function addValidator(validator, { debounced, level } = {
        debounced: false,
        level: 'error',
    }) {
        var _a;
        const prop = level === 'error' ? 'validate' : 'warn';
        (_a = config.debounced) !== null && _a !== void 0 ? _a : (config.debounced = {});
        const validateConfig = debounced ? config.debounced : config;
        if (!validateConfig[prop]) {
            validateConfig[prop] = [validator];
        }
        else {
            validateConfig[prop] = [
                ...validateConfig[prop],
                validator,
            ];
        }
    }
    function addTransformer(transformer) {
        if (!config.transform) {
            config.transform = [transformer];
        }
        else {
            config.transform = [
                ...config.transform,
                transformer,
            ];
        }
    }
    const extender = Array.isArray(config.extend)
        ? config.extend
        : [config.extend];
    let currentExtenders = [];
    const _getCurrentExtenders = () => currentExtenders;
    const _setCurrentExtenders = (extenders) => {
        currentExtenders = extenders;
    };
    const { isSubmitting, isValidating, data, errors, warnings, touched, isValid, isDirty, cleanup, start, validateErrors, validateWarnings, interacted, } = createStores(adapters.storeFactory, config);
    const originalUpdate = data.update;
    const originalSet = data.set;
    const transUpdate = (updater) => originalUpdate((values) => deepSetKey(common.executeTransforms(updater(values), config.transform)));
    const transSet = (values) => originalSet(deepSetKey(common.executeTransforms(values, config.transform)));
    data.update = transUpdate;
    data.set = transSet;
    const helpers = createHelpers({
        extender,
        config,
        addValidator,
        addTransformer,
        validateErrors,
        validateWarnings,
        _getCurrentExtenders,
        stores: {
            data,
            errors,
            warnings,
            touched,
            isValid,
            isValidating,
            isSubmitting,
            isDirty,
            interacted,
        },
    });
    const { createSubmitHandler, handleSubmit } = helpers.public;
    currentExtenders = extender.map((extender) => extender({
        stage: 'SETUP',
        errors,
        warnings,
        touched,
        data,
        isDirty,
        isValid,
        isValidating,
        isSubmitting,
        interacted,
        config,
        addValidator,
        addTransformer,
        setFields: helpers.public.setFields,
        reset: helpers.public.reset,
        validate: helpers.public.validate,
        handleSubmit,
        createSubmitHandler,
    }));
    const formActionConfig = Object.assign({ config, stores: {
            data,
            touched,
            errors,
            warnings,
            isSubmitting,
            isValidating,
            isValid,
            isDirty,
            interacted,
        }, createSubmitHandler,
        handleSubmit, helpers: Object.assign(Object.assign({}, helpers.public), { addTransformer,
            addValidator }), extender,
        _getCurrentExtenders,
        _setCurrentExtenders }, helpers.private);
    const { form } = createFormAction(formActionConfig);
    return Object.assign({ data,
        errors,
        warnings,
        touched,
        isValid,
        isSubmitting,
        isValidating,
        isDirty,
        interacted,
        form,
        cleanup, startStores: start }, helpers.public);
}

exports.FelteSubmitError = FelteSubmitError;
exports.createEventConstructors = createEventConstructors;
exports.createField = createField;
exports.createForm = createForm;
exports.getValueFromStore = get;
Object.keys(common).forEach(function (k) {
    if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () { return common[k]; }
    });
});
//# sourceMappingURL=index.cjs.map
